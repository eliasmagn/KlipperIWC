# KlipperIWC Konzept

KlipperIWC ist eine schlanke Weboberfläche, die ausschließlich Konfigurationen für Klipper-basierte 3D-Druckerinstallationen generiert. Die Anwendung stellt einen kleinen FastAPI-Service bereit, der Designer-Workflows und Exportfunktionen kapselt, ohne dabei eine direkte Kommunikation mit laufenden Klipper-Instanzen aufzubauen. Benutzerverwaltung und Login sind bewusst nicht Teil des aktuellen Umfangs und werden erst in einer späteren Ausbaustufe berücksichtigt. Ziel ist eine wartbare, erweiterbare und für verschiedene Installationsziele (Bare Metal, virtuelle Maschine, Container) leicht deploybare Lösung, die reproduzierbare `klipper.conf`-Profile liefert.

Neue Board- und Druckerdefinitionen entstehen zunächst über Beiträge im GitHub-Repository. In einer späteren Phase mit Login-System sollen Anwender fehlende Hardware direkt während der Konfiguration ergänzen können. Als Zwischenschritt stehen eine neue Landingpage, der Board-Designer sowie ein interaktiver Drucker-Designer bereit. Der Drucker-Designer erlaubt Bild-Uploads, markiert Schalter, Extruder, Sensoren, Lüfter oder Stepper mittels Rechtecken, Kreisen und Maßpfeilen und nimmt Rotationsdistanzen für Antriebe auf. Eine korrigierte Koordinatenberechnung berücksichtigt die aktuelle ViewBox-Skalierung, sodass Markierungen exakt der Cursor-Position folgen. Beide Designer erzeugen angereicherte Visualisierungen, die unmittelbar als JSON-Dokumente gespeichert werden können. Dadurch lassen sich Definitionen dauerhaft versionieren, optional freigeben und später innerhalb des geplanten Konfigurations-Generators zusammenführen, der vollständige `klipper.conf`-Profile erzeugt.
Neue Board- und Druckerdefinitionen entstehen zunächst über Beiträge im GitHub-Repository. In einer späteren Phase mit Login-System sollen Anwender fehlende Hardware direkt während der Konfiguration ergänzen können. Als Zwischenschritt stehen eine neue Landingpage, der Board-Designer sowie ein interaktiver Drucker-Designer bereit. Der Drucker-Designer erlaubt Bild-Uploads, markiert Schalter, Extruder, Sensoren, Lüfter oder Stepper mittels Rechtecken, Kreisen und Maßpfeilen und nimmt Rotationsdistanzen für Antriebe auf. Beide Designer verfügen zusätzlich über einen 3D-CAD-Modus, der STEP-Dateien importiert, eine frei bewegliche Vorschau bereitstellt und Marker für Geräte, Führungen, Riemen, Kabel oder Sensorik direkt im Raum verankert. Die Oberfläche wurde auf ein Overlay-Layout umgestellt, sodass Toolbar, Statusmeldungen und die CAD-spezifischen Werkzeuge nicht länger eigene Spalten blockieren, sondern als schwebende Panels über der aktiven Ansicht liegen. Während lang laufende STEP-Imports sorgt ein integrierter Fortschrittsindikator für sichtbares Feedback und fängt Parserantworten ohne Polygonkoordinaten ab, damit fehlende Meshdaten keine Renderfehler mehr auslösen. Die 3D-Markierungen werden gemeinsam mit den 2D-Annotationen verwaltet und ermöglichen es, räumliche Abhängigkeiten und Kabelwege bereits in der Entwurfsphase zu dokumentieren. Beide Designer erzeugen angereicherte Visualisierungen, die unmittelbar als JSON-Dokumente gespeichert werden können. Dadurch lassen sich Definitionen dauerhaft versionieren, optional freigeben und später innerhalb des geplanten Konfigurations-Generators zusammenführen, der vollständige `klipper.conf`-Profile erzeugt.
Die Landingpage führt Besucher inzwischen durch einen geführten Dreischritt: Zuerst wird ein Board gewählt oder neu angelegt, anschließend entsteht die Druckerhardware-Beschreibung und perspektivisch folgt der Konfigurations-Assistent. Der Drucker-Designer bündelt das 2D-Layout samt Hintergrundbild und die 3D-CAD-Ansicht jetzt in einem gemeinsamen Workspace, der sich per Umschalter wechseln lässt. Damit liegen Bildreferenz, Annotationen und STEP-Visualisierung im selben Kontext und lassen sich ohne Layoutsprung aktivieren. Der Board-Designer folgt dem gleichen Muster und schaltet zwischen 2D-Overlay und 3D-Explorer, ohne den Arbeitsbereich zu verlassen. Der STEP-Import setzt weiterhin auf `occt-import-js`, wird jedoch via jsDelivr geladen, sodass die Bibliothek auch dann verfügbar bleibt, wenn der direkte Zugriff auf Raw-GitHub blockiert ist. Um High-DPI-Displays effizient auszunutzen, begrenzen die Viewer ihre Rendering-Auflösung jetzt über einen konfigurierbaren Pixelratio-Deckel und reagieren auf Änderungen der Display-Skalierung oder Monitorwechsel automatisch mit einer Größenanpassung. Zusätzlich steuern angepasste Tessellationsparameter (`linearTolerance`, `angularTolerance`, `maxEdgeLength`) der STEP-Parser jetzt aktiv die Dreiecksanzahl und liefern so auch bei großen Baugruppen eine besser handhabbare Geometrie. Gemeinsam genutzte, leichte Materialien (Front-Side MeshStandard) reduzieren GPU-Overhead, ohne die Erkennbarkeit der Komponenten zu verlieren.

Für die Statuskommunikation existieren aktuell eine lesende HTTP-API (`/api/status`, `/api/jobs`, `/api/temperatures`) sowie ein Websocket-Gateway (`/ws/status`), die ausschließlich strukturierte Demo-Daten liefern. Diese Schnittstellen dienen als visuelle Vorschau für UI-Komponenten und ersetzen nicht die Telemetrie einer echten Klipper-Instanz. Persistenz- und Broadcast-Mechanismen verbleiben als Mock-Infrastruktur, um künftige Visualisierungen mit Testdaten zu speisen, ohne eine Verbindung zu produktiven Druckern aufzubauen. Authentifizierungs- und Rate-Limit-Platzhalter werden deshalb als optionale Schutzmechanismen betrachtet, die rein für Test- und Showcase-Installationen relevant sind.

Ein neuer Upload- und Moderations-Workflow ermöglicht es, Board-Grafiken zentral zu speichern. Über `/api/board-assets` nehmen Uploads die Grafikdateien samt Metadaten entgegen, berechnen Prüfsummen und persistieren die Dateien über einen austauschbaren Storage-Layer (lokales Dateisystem oder S3-kompatible Buckets). Ergänzend dazu stehen die REST-Endpunkte `/api/definitions/boards` und `/api/definitions/printers` bereit, über die Designer-Ergebnisse dauerhaft in SQLite abgelegt werden. Die Tabellen hinterlegen Slugs, Beschreibungen, Vorschaulinks und das vollständige JSON der Definitionen. Service-Funktionen kapseln Speicherung, Konsistenzprüfungen und Zugriffskontrollen, wodurch sich spätere Integrationen in UI- oder Automatisierungs-Workflows vereinfachen.

Die Anwendung erwartet ein Registry-Verzeichnis für strukturierte Board-Definitionen, das standardmäßig als `board-definitions/` referenziert wird. Um das Repository schlank zu halten, ist dieser Ordner nicht eingecheckt und muss lokal angelegt oder per `BOARD_DEFINITION_ROOT` auf einen externen Speicherort gelegt werden. Beiträge können Definitionen in separaten Repositories pflegen und beispielsweise über Git-Submodule, Release-Artefakte oder Deployment-Schritte einbinden. Die Dateien folgen dem Schema `schemas/board-definition.schema.json`, welches Pflichtfelder für Metadaten, Steckverbinder und Pins vorgibt und per `x-klipperiwc-version` versioniert ist. Ein dedizierter Service (`klipperiwc.services.board_registry`) und neue API-Routen (`/api/boards/*`) stellen sicher, dass Definitionen automatisiert validiert, aufgelistet und nach Revisionen gruppiert werden können. So lassen sich Design-Daten aus dem Board-Designer schrittweise in wiederverwendbare JSON-Definitionen überführen, bis ein vollwertiger UI-basierter Workflow bereitsteht.
Die Moderations-API erzwingt dabei einen abgestuften Zugriff: Öffentliche Endpunkte liefern ausschließlich geprüfte, freigegebene Assets, während Upload- und Moderator-Token erweiterten Zugriff auf Entwürfe und Warteschlangen gewähren. Dadurch lässt sich der Prüfprozess sauber vom öffentlichen Datenbestand trennen und dennoch nahtlos in bestehende Tools integrieren.

Der Printer-Designer führt Nutzer inzwischen durch einen Pflichtschritt zur Profilerstellung: Name, Bauform, Hotend, Steuerboard, Lead Screws, Riemen, Übersetzungen und Heizbett werden aus einer gepflegten Konstantenliste gewählt, Tooltips verweisen auf die passende Klipper-Dokumentation und der Upload der Hintergrundgrafik wird erst nach benannter Maschine freigegeben. Eine zusätzliche Konfigurationsübersicht fasst die relevanten Klipper-Sections zusammen und liefert Direktlinks zur Referenz. Für die 3D-Ansicht wird `three.js` nicht länger über GitHub-CDNs geladen, sondern als lokales Asset (`/static/js/three.min.js`) ausgeliefert, sodass Deployments offline reproduzierbar bleiben.
