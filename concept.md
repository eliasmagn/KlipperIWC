# KlipperIWC Konzept

KlipperIWC ist eine schlanke Weboberfläche, die Statusinformationen und Steuerbefehle für eine Klipper-basierte 3D-Druckerinstallation bereitstellt. Die Anwendung stellt einen kleinen FastAPI-Service zur Verfügung, der neben einer HTTP-API auch Websocket-basierte Live-Updates ausliefert und perspektivisch um Integrationen in bestehende Drucker-Workflows erweitert wird. Benutzerverwaltung und Login sind bewusst nicht Teil des aktuellen Umfangs und werden erst in einer späteren Ausbaustufe berücksichtigt. Ziel ist eine wartbare, erweiterbare und für verschiedene Installationsziele (Bare Metal, virtuelle Maschine, Container) leicht deploybare Lösung.

Neue Board- und Druckerdefinitionen entstehen zunächst über Beiträge im GitHub-Repository. In einer späteren Phase mit Login-System sollen Anwender fehlende Hardware direkt während der Konfiguration ergänzen können. Als Zwischenschritt steht bereits eine interaktive Board-Designer-Seite zur Verfügung, auf der Pins, Stecker und MCU-Signale mit Rechtecken oder Kreisen markiert und beschriftet werden können. Diese Vorarbeit erleichtert das spätere Überführen der Daten in den produktiven Workflow.

Für die Statuskommunikation existieren aktuell eine lesende HTTP-API (`/api/status`, `/api/jobs`, `/api/temperatures`) sowie ein Websocket-Gateway (`/ws/status`), die strukturierte Demo-Daten liefern und als Fundament für die Echtzeit-Anbindung dienen. Die entsprechenden Pydantic-Modelle bilden das Domain-Modell ab und können bei Bedarf unkompliziert erweitert werden. Eingehende Statuspakete werden zudem persistiert: Ein dedizierter Service-Layer legt Status-, Temperatur- und Job-Historien in SQLite ab, damit spätere Visualisierungen auf echte Verlaufsdaten zugreifen können. Ein periodischer Hintergrundjob sorgt dafür, dass Altdaten anhand einer konfigurierbaren Aufbewahrungsfrist automatisch bereinigt werden.

Erste Steuerbefehle (Start, Stop, Pause, Not-Aus) werden über die Route `/api/control/*` bereitgestellt und an eine konfigurierte Klipper-Instanz weitergeleitet. Ein abgesicherter Service-Layer nutzt HTTPX, respektiert Zeitlimits und leitet Fehlermeldungen kontrolliert an die API weiter, damit das Frontend verständliche Rückmeldungen erhält. Sicherheitsmechanismen wie bestätigungspflichtige Tokens (`X-Control-Token`) und optionale IP-Whitelists schützen die sensiblen Endpunkte, solange keine umfassende Benutzerverwaltung existiert.

Ein neuer Upload- und Moderations-Workflow ermöglicht es, Board-Grafiken zentral zu speichern. Über `/api/board-assets` nehmen Uploads die Grafikdateien samt Metadaten entgegen, berechnen Prüfsummen und persistieren die Dateien über einen austauschbaren Storage-Layer (lokales Dateisystem oder S3-kompatible Buckets). Die zugehörigen Datenbanktabellen hinterlegen Sichtbarkeit, Reviewer-Informationen und eine Moderationshistorie, sodass eingereichte Beiträge erst nach Freigabe öffentlich sichtbar sind. Service-Funktionen kapseln die Speicherung, Konsistenzprüfungen und Zugriffskontrollen per API-Token, wodurch sich spätere Integrationen in UI- oder Automatisierungs-Workflows vereinfachen.
